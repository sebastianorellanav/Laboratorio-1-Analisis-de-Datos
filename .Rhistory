source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
View(pruebas)
View(pruebas)
source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
if(length(dev.list())!=0){
dev.off(dev.list()["RStudioGD"])
}
rm(list=ls())
source('C:/Users/Gary/Desktop/GITHUB/Laboratorio-1-Analisis-de-Datos/main2.r', encoding = 'UTF-8', echo=TRUE)
bp2 <- ggboxplot(
datos.long2,
x = "variable", y = "value",
fill = "variable"
)
print(bp2)
distribucion
source('C:/Users/sebastian/OneDrive/Desktop/Usach/AnalisisDatos/Laboratorio-1-Analisis-de-Datos/main2.r')
source('C:/Users/sebastian/OneDrive/Desktop/Usach/AnalisisDatos/Laboratorio-1-Analisis-de-Datos/main2.r')
# Se define un alfa = 0.05 para contrastar con el resultado obtenido
shapirotest <- apply(pruebas,2,shapiro.test)
print(shapirotest)
# Se define un alfa = 0.05 para contrastar con el resultado obtenido
shapiroTest.p1 <- shapiro.test(pruebas$clumpThickness)
print(shapiroTest.p1)
# Se define un alfa = 0.05 para contrastar con el resultado obtenido
shapiroTest.p1 <- shapiro.test(pruebas$marginalAdhesion)
print(shapiroTest.p1)
par(mfrow=c(3,3))
# Se aplica el test a todas las variables
shapirotest <- apply(pruebas,2,shapiro.test)
# Se muestra el resultado del test
par(mfrow=c(3,3))
print(shapirotest)
# Se muestra el gráfico
pie(valores, ,labels = etiquetas,col=rainbow(2), main="% Casos Benignos vs Malignos")
# Se muestra el gráfico
pie(valores, labels = etiquetas,col=rainbow(2), main="% Casos Benignos vs Malignos")
# Por otro lado, se utiliza la función hist() para crear un histograma de los
# datos de cada grupo. Esto se usa como primera aproximación para
# observar si existe algún tipo de asimetría o si los datos se comportan
# de forma normal.
ign<-mapply(hist,pruebas,main=colnames(pruebas),col="lightsteelblue",xlab="Puntaje")
# Por otro lado, se utiliza la función hist() para crear un histograma de los
# datos de cada grupo. Esto se usa como primera aproximación para
# observar si existe algún tipo de asimetría o si los datos se comportan
# de forma normal.
ign<-mapply(hist,pruebas,main=colnames(pruebas),col="lightsteelblue",xlab="Puntaje")
# Se aplica el test a todas las variables
shapirotest <- apply(pruebas,2,shapiro.test)
# Se muestra el resultado del test
print(shapirotest)
par(mfrow=c(3,3))  #PARA QUE ES ESTO?
# Se muestra el gráfico
pie(valores, labels = etiquetas,col=rainbow(2), main="% Casos Benignos vs Malignos")
# Por otro lado, se utiliza la función hist() para crear un histograma de los
# datos de cada grupo. Esto se usa como primera aproximación para
# observar si existe algún tipo de asimetría o si los datos se comportan
# de forma normal.
par(mfrow=c(3,3))
ign<-mapply(hist,pruebas,main=colnames(pruebas),col="lightsteelblue",xlab="Puntaje")
# Se muestra el gráfico
par(mfrow=c(1,1))
pie(valores, labels = etiquetas,col=rainbow(2), main="% Casos Benignos vs Malignos")
i
# Se aplica el test de correlación
df.cor = cor(pruebas, method = 'spearman')
source('C:/Users/sebastian/OneDrive/Desktop/Usach/AnalisisDatos/Laboratorio-1-Analisis-de-Datos/main2.r')
######################################################################################################
##########################            Bibliotecas          ###########################################
library(modeest)
library(ggpubr)
library(cowplot)
library(corrplot)
library(ggcorrplot)
library(reshape2)
library(RColorBrewer)
# Se eliminan los gráficos y variables antiguas
rm(list=ls())
if(length(dev.list())!=0){
dev.off(dev.list()["RStudioGD"])
}
# Se definen los nombres de las columnas, estos son los mismos de provistos por la base de datos
columnas = c("id",
"clumpThickness",
"uniformityCellSize",
"uniformityCellShape",
"marginalAdhesion",
"singleEpithCellSize",
"bareNuclei",
"blandChromatin",
"normalNucleoli",
"mitoses",
"class"
)
# Se importa la base de dato mediante la url del repositorio UCI Machine Learning
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data"
df = read.csv(url,
header = F,
sep=",",
col.names = columnas)
# Se eliminan los datos nulos del data-set
df = df[!(df$bareNuclei == "?"),]
# Se convierten los datos a tipo numérico
df[ , ] = apply(df[ , ], 2,function(x) as.numeric(as.character(x)) )
# Se elimina la columna id al no ser relevante para el análisis
df$id<-NULL
# Se cambian los valores de las clases por un String para una mejor visualización
df$class <- as.character(df$class)
df$class[df$class == "2"] <- "Benigno"
df$class[df$class == "4"] <- "Maligno"
# A continuación se procede a analizar posibles outliers en los datos
pruebas = df
pruebas$id <- NULL
pruebas$class<- NULL
# Se conviernten los datos a tipo long para ser graficados
datos.long<-melt(pruebas)
# Se crea un gráfico de cajas
bp1 <- ggboxplot(datos.long,
x = "variable",
y = "value",
fill = "variable")
# Se muestra el gráfico
print(bp1)
# Se Cambian los outliers encontrados por la media de la correspondiente variable
df$marginalAdhesion[df$marginalAdhesion > 5] <- mean(df$marginalAdhesion)
df$singleEpithCellSize[df$singleEpithCellSize > 4] <- mean(df$singleEpithCellSize)
df$blandChromatin[df$blandChromatin > 4] <- mean(df$blandChromatin)
df$normalNucleoli[df$normalNucleoli > 5] <- mean(df$normalNucleoli)
df$mitoses[df$mitoses > 2] <- mean(df$mitoses)
# Se elimina el id y la clase para seguir analizando las variables por separado
pruebas = df
pruebas$id <- NULL
pruebas$class<- NULL
# Se convierten a tipo long los datos sin outliers
datos.long2<-melt(pruebas)
# Se crea un gráfico cuartil-cuartil para observar si se eliminaron correctamente
# los valores atípicos
qq2 <- ggqqplot(datos.long2,
x = "value",
color = "variable")
qq2 <- qq2 + facet_wrap(~ variable)
# Se muestra el gráfico
print(qq2)
# En adición, se crea un grafico de cajas nuevamente para observar los datos filtrados
bp2 <- ggboxplot(datos.long2,
x = "variable", y = "value",
fill = "variable")
# Se muestra el gráfico
print(bp2)
# Se calcula la media para todas las variables
medias = apply(pruebas, 2, mean)
# Se calcula la mediana para todas las variables
medianas =  apply(pruebas, 2, median)
# Se calcula la moda para todas la variables
modas = apply(pruebas, 2, mlv,  method = "mfv")
# se calcula la desviación estandar para todas las variables
desviaciones = apply(pruebas, 2, sd)
# Se calcula la varianza para todas las variables
varianzas = apply(pruebas, 2, var)
# Se calcula el rango de cada una de las variables
rangos = apply(pruebas, 2, range)
# Se crea una tabla para mostrar los resultados
tabla = matrix(c(medias,
medianas,
modas,
varianzas,
desviaciones,
rangos),
ncol=9,
byrow=TRUE)
# Se le asignan los nombres de las variables a las columnas
colnames(tabla) =  c("clumpThickness",
"uniformityCellSize",
"uniformityCellShape",
"marginalAdhesion",
"singleEpithCellSize",
"bareNuclei",
"blandChromatin",
"normalNucleoli",
"mitoses")
# Se le asignan los nombres de las métricas a las filas
rownames(tabla) = c("media","mediana","moda","varianza","SD")
# Se le asignan los nombres de las métricas a las filas
rownames(tabla) = c("media","mediana","moda","varianza","SD", "Rango")
# Se crea una tabla para mostrar los resultados
tabla = matrix(c(medias,
medianas,
modas,
varianzas,
desviaciones,
rangos),
ncol=9,
byrow=TRUE)
# Se le asignan los nombres de las variables a las columnas
colnames(tabla) =  c("clumpThickness",
"uniformityCellSize",
"uniformityCellShape",
"marginalAdhesion",
"singleEpithCellSize",
"bareNuclei",
"blandChromatin",
"normalNucleoli",
"mitoses")
# Se le asignan los nombres de las métricas a las filas
rownames(tabla) = c("media","mediana","moda","varianza","SD", "Rango")
# Se convierte la variable en una tabla
tabla=as.table(tabla)
# Se muestran los resultados
print(tabla)
# Se le asignan los nombres de las métricas a las filas
rownames(tabla) = c("media","mediana","moda","varianza","SD", "rango")
# Se crea una tabla para mostrar los resultados
tabla = matrix(c(medias,
medianas,
modas,
varianzas,
desviaciones),
ncol=9,
byrow=TRUE)
# Se le asignan los nombres de las variables a las columnas
colnames(tabla) =  c("clumpThickness",
"uniformityCellSize",
"uniformityCellShape",
"marginalAdhesion",
"singleEpithCellSize",
"bareNuclei",
"blandChromatin",
"normalNucleoli",
"mitoses")
# Se le asignan los nombres de las métricas a las filas
rownames(tabla) = c("media","mediana","moda","varianza","SD")
# Se convierte la variable en una tabla
tabla=as.table(tabla)
# Se muestran los resultados
print(tabla)
# Por otro lado, se utiliza la función hist() para crear un histograma de los
# datos de cada grupo. Esto se usa como primera aproximación para
# observar si existe algún tipo de asimetría o si los datos se comportan
# de forma normal.
par(mfrow=c(3,3))
ign<-mapply(hist,
pruebas,
main=colnames(pruebas),
col="lightsteelblue",
xlab="Puntaje")
# Se aplica el test a todas las variables
shapirotest <- apply(pruebas,2,shapiro.test)
# Se muestra el resultado del test
print(shapirotest)
# Se muestra el resultado del test
print(shapirotest)
# Primero se suma la cantidad de observaciones que pertenecen a benigno y las que pertenecen a maligno
B = sum(df$class == "Benigno",na.rm=TRUE)
M = sum(df$class == "Maligno",na.rm=TRUE)
# Se calculan los porcentajes de cada clase
Tot = B+M
PB= B/Tot
PM= M/Tot
# Se muestran los resultados
cat("Totales:",Tot,"\nBenignos:",B,"Malignos:",M,"\nPorcentaje Benigno:",PB,"Porcentaje Maligno:",PM)
# Se crea un gráfico para visualizar la distribución por clases.
valores <- c(PB, PM)
etiquetas <- c("Benignos","Malignos")
etiquetas <- paste(etiquetas,round(valores,2))
etiquetas <- paste(etiquetas,"%",sep="")
# Se muestra el gráfico
par(mfrow=c(1,1))
pie(valores, labels = etiquetas,col=rainbow(2), main="% Casos Benignos vs Malignos")
# Se crea una función para comparar cada variable con la clase de cancer
# a la cual pertence la observación
grafico <- function(df,aes,y_string){
boxplt =  ggboxplot(data = df,
x = "class",
y = y_string,
color = "class",) + border()
ydens = axis_canvas(boxplt,
axis = "y",
coord_flip = TRUE) +
geom_density(data = df,
aes, alpha = 0.7,
size = 0.2) +
coord_flip()
boxplt = insert_yaxis_grob(boxplt,
ydens,
grid::unit(.2, "null"),
position = "right")
ggdraw(boxplt)
}# Fin de la función
# Se llama a la función para crear los gráficos
a<-grafico(df,aes(x = clumpThickness, fill = class),"clumpThickness")
b<-grafico(df,aes(x = uniformityCellSize, fill = class),"uniformityCellSize")
c<-grafico(df,aes(x = uniformityCellShape, fill = class),"uniformityCellShape")
d<-grafico(df,aes(x = marginalAdhesion, fill = class),"marginalAdhesion")
e<-grafico(df,aes(x = singleEpithCellSize, fill = class),"singleEpithCellSize")
f<-grafico(df,aes(x = bareNuclei, fill = class),"bareNuclei")
g<-grafico(df,aes(x = blandChromatin, fill = class),"blandChromatin")
h<-grafico(df,aes(x = normalNucleoli, fill = class),"normalNucleoli")
i<-grafico(df,aes(x = mitoses, fill = class),"mitoses")
ggarrange(a,b,c,d)
ggarrange(e,f,g,h)
i
# Se aplica el test de correlación
df.cor = cor(pruebas, method = 'spearman')
# Se grafican los resultados
ggcorrplot(df.cor,hc.order = TRUE,type = "full",lab = TRUE)
source('C:/Users/sebastian/OneDrive/Desktop/Usach/AnalisisDatos/Laboratorio-1-Analisis-de-Datos/main2.r')
